#define COMMON_STD_MIDIP
(
   (inverted FALSE) (up FALSE) (append_length TRUE) (compress TRUE)
   (message_type midi_parser) (mp.up FALSE) (idle)
   (firstgem 0) (firstbeat 0) (breaknum 0) (note_start 0) (note_prevend 0)
   (last_note_start 0) (final_note 0) (tracker 1) (tracker2 0)
   (capture 0) (last_kick_end 0) (pass2 0)
   (batch_start_beat -1) (batch_notes {array ()})
   (log_enabled FALSE) (detailed_keys_log FALSE)
   (midi
      {unless [firstgem]
         {set [firstgem] TRUE}
         {set [breaknum] 0}
         {set [firstbeat] {int $mp.start}}
         {set [last_note_start] 0} ; cache note start time
         {set [batch_start_beat] -1}
         {set [batch_notes] {array ()}}
         {set [log_enabled] FALSE}
         {set [detailed_keys_log] FALSE}
         {if {|| {== [instrument] drum} {== [instrument] real_drum}}
            {set [capture] TRUE}
            {set [last_kick_end] 0}
         }
         {if {> [firstbeat] 16}
            {if [log_enabled]
               {notify {sprint [instrument] "eval_note_tracker progress: " [tracker]}}
               {notify {sprint [instrument] "eval_note_tracker2 progress: " [tracker2]}}
               {notify {eval {var {sprint [instrument] "_note_tracker"}}}}
            }
            {if [pass2]
               {set_elem {eval {var {sprint [instrument] "_note_tracker"}}} ;only done in eval
                  [tracker]
                  {array ("delay_0" 0 [firstbeat])}
               }
            }
            {set [breaknum] 1}
            {++ [tracker]}
         }
      }
      {if {&& {>= $mp.prev_end 16} {< $mp.prev_end 10000}}
         {set [note_start] {int $mp.start}}
         {set [note_prevend] {int {- [note_start] $mp.prev_end}}}
         {if [log_enabled]
            {notify {sprint [instrument] "eval_note_tracker progress: " [tracker]}}
            {notify {sprint [instrument] "eval_note_tracker2 progress: " [tracker2]}}
            {notify {eval {var {sprint [instrument] "_note_tracker"}}}}
         }
         {if [pass2]
            {set_elem {eval {var {sprint [instrument] "_note_tracker"}}} ;only done in eval
               [tracker]
               {array ({sprint "delay_" [breaknum]} [note_prevend] [note_start])}
            }
         }
         {++ [breaknum]}
         {++ [tracker]}
      }
      {if {== $mp.val 116} ;overdrive
         {if [pass2]
            {set_elem {eval {var {sprint [instrument] "_note_tracker"}}} ;only done in eval
               [tracker]
               {array ({sprint "overdrive_" {int $mp.start}} {int $mp.start} {int $mp.end})}
            }
         }
         {++ [tracker]}
      }
      {if {|| {== $mp.val 103} {== $mp.val 115}} ;solo
         {if [pass2]
            {set_elem {eval {var {sprint [instrument] "_note_tracker"}}} ;only done in eval
               [tracker]
               {array ({sprint "solo_" {int $mp.start}} {int $mp.start} {int $mp.end})}
            }
         }
         {++ [tracker]}
      }
      {if {== $mp.val 120} ;bre
         ;{++ [tracker]}
         {set $bre_start_time $mp.start}
      }
      {set [final_note] {int $mp.end}}
      {if {> [final_note] $dx_final_note}
         {set $dx_final_note [final_note]}
      }
      {if {&& {!= $mp.val 103} {!= $mp.val 115} {!= $mp.val 116} {!= $mp.val 120}} ;cache last note in chart
         {set_var {sprint [instrument] "_last_note_time"} {int $mp.end}}
         {set_var {sprint "dx_final_note_" [instrument]} {int $mp.end}}
         {if {> {int $mp.end} $dx_final_note}
            {set $dx_final_note {int $mp.end}}
         }
      }
      {if {&& {!= [instrument] harm} {!= [instrument] vocals}} ;vocals has no perfects
         {if {&& {!= $mp.val 103} {!= $mp.val 115} {!= $mp.val 116} {!= $mp.val 120}}
            {if $dx_perfects_indicator
               ;all instruments BESIDES drum and keys
               {if {&& {!= [instrument] drum} {!= [instrument] real_drum} {!= [instrument] keys} {!= [instrument] real_keys}}
                  {if {> {- $mp.start [last_note_start]} 0}
                     
                     {if [pass2]
                        {set_elem {eval {var {sprint [instrument] "_note_tracker_2"}}} ;only done in eval
                           [tracker2]
                           {* {beat_to_seconds $mp.start} 1000}
                        }
                     }
                     {++ [tracker2]}
                     {set [last_note_start] $mp.start} ; cache note start time
                  }
               }
               ; DRUMS
               {if {|| {== [instrument] drum} {== [instrument] real_drum}}
                  ;if parser jumped backwards, stop capturing
                  {if {< {- $mp.start [last_note_start]} 0}
                     {set [capture] FALSE}
                  }
                  ; only push if capture is active and ordering makes sense
                  {if {&& [capture] {>= {- $mp.end [last_note_start]} 0}}
                     ; RB3E 2x kick overlap workaround:
                     {unless
                        {&&
                           {|| {== $mp.val 95} {== $mp.val 96}}
                           {< {- $mp.start [last_kick_end]} 0}
                        }
                        {if [pass2]
                           {set_elem {eval {var {sprint [instrument] "_note_tracker_2"}}} ;only done in eval
                              [tracker2]
                              {* {beat_to_seconds $mp.start} 1000}
                           }
                        }
                        {++ [tracker2]}
                        {set [last_note_start] {int $mp.start}}

                        ; update kick end time for 95/96
                        {if {|| {== $mp.val 95} {== $mp.val 96}}
                           {set [last_kick_end] $mp.end}
                        }
                     }
                  }
               }
               ;KEYS
               {if {|| {== [instrument] keys} {== [instrument] real_keys}}

                  ; Decide whether this note is a "playable note" for perfect tracking.
                  ; keys: only 96–100
                  ; real_keys: anything except 115/116/120 (playable 48–72)
                  {set [is_playable_note]
                     {if_else {== [instrument] keys} ;this is probably redundant based on the above mp.val check
                        {|| {== $mp.val 96} {== $mp.val 97} {== $mp.val 98} {== $mp.val 99} {== $mp.val 100}}
                        {&& {!= $mp.val 115} {!= $mp.val 116} {!= $mp.val 120}}
                     }
                  }

                  {if [is_playable_note]

                     {if [detailed_keys_log]
                        {set [detailed_keys_log]
                           {if_else {< {beat_to_seconds $mp.start} 60} TRUE FALSE}
                        }
                        {if [detailed_keys_log]
                           {notify {sprint "starting parsing note"}}
                        }
                        {if {<= {eval {var {sprint [instrument] "_note_tracker_2_size"}}} 4000}
                           {if [detailed_keys_log]
                              {notify
                                 {sprint
                                    {eval {var {sprint [instrument] "_note_tracker_2_size"}}} ","
                                    {* {beat_to_seconds $mp.start} 1000} "," {* {beat_to_seconds $mp.end} 1000} ","
                                    $mp.start "," $mp.end "," [batch_start_beat] ","
                                    $mp.length "," $mp.prev_start "," $mp.prev_end "," $mp.data "," $mp.val
                                 }
                              }
                           }
                        }
                     }

                    ; If this note starts a new batch (same 0.02 logic)
                    {if {> {- $mp.start [batch_start_beat]} 0.02}

                        ; Process previous batch (if any)
                        {if {> {size [batch_notes]} 0}
                           {set [diff_end_found] FALSE}

                           {if {> {size [batch_notes]} 1}
                              {set $first_end {elem {elem [batch_notes] 0} 1}}
                              {foreach $n [batch_notes]
                                 {if {!= {elem $n 1} $first_end}
                                    {set [diff_end_found] TRUE}
                                 }
                              }
                           }

                           ; Push all notes if differing end times exist, else push only first
                           {if_else {== [diff_end_found] TRUE}
                              {foreach $n [batch_notes]
                                 {do
                                    {if [pass2]
                                       {set_elem {eval {var {sprint [instrument] "_note_tracker_2"}}}
                                          [tracker2]
                                          {* {beat_to_seconds {elem $n 0}} 1000}
                                       }
                                    }
                                    {++ [tracker2]}
                                 }
                              }
                                 {do
                                    {set $n {elem [batch_notes] 0}}
                                    {if [pass2]
                                       {set_elem {eval {var {sprint [instrument] "_note_tracker_2"}}}
                                          [tracker2]
                                          {* {beat_to_seconds {elem $n 0}} 1000}
                                       }
                                    }
                                    {++ [tracker2]}
                                 }
                              }
                           }

                        ; Start new batch
                        {set [batch_start_beat] $mp.start}
                        {set [batch_notes] {array ()}}
                     }

                     ; Add note to batch only if no matching val already exists in batch
                     {set [do_add_note] TRUE}
                     {if {> {size [batch_notes]} 0}
                        {foreach $n [batch_notes]
                           {if {== {elem $n 2} $mp.val}
                              {set [do_add_note] FALSE}
                           }
                        }
                     }

                     {if [do_add_note]
                        {set $dx_note {array ($mp.start $mp.end $mp.val)}}
                        {push_back [batch_notes] $dx_note}
                     }

                     {if [detailed_keys_log]
                        {notify {sprint "[batch_notes] = " [batch_notes]}}
                        {if {> {size [batch_notes]} 0}
                           {notify {sprint "[batch_notes].0 = " {elem [batch_notes] 0}}}
                           {notify {sprint "[batch_notes].0.0 = " {elem {elem [batch_notes] 0} 0}}}
                           {notify {sprint "[batch_notes].0.1 = " {elem {elem [batch_notes] 0} 1}}}
                        }
                        {notify {sprint "Currently " {size [batch_notes]} " notes in cache"}}
                        {notify {sprint "finished parsing note"}}
                     }
                  }
               }
            }
         }
      }
   )
   (term
      {if {&& $dx_perfects_indicator {|| {== [instrument] keys} {== [instrument] real_keys}}}
         {if {> {size [batch_notes]} 0}
            {set [diff_end_found] FALSE}

            {if {> {size [batch_notes]} 1}
               {set $first_end {elem {elem [batch_notes] 0} 1}}
               {foreach $n [batch_notes]
                  {if {!= {elem $n 1} $first_end}
                     {set [diff_end_found] TRUE}
                  }
               }
            }

            ; Push all notes if differing end times exist, else push only first
            {if_else {== [diff_end_found] TRUE}
               {foreach $n [batch_notes]
                  {do
                     {if [pass2]
                        {set_elem {eval {var {sprint [instrument] "_note_tracker_2"}}}
                           [tracker2]
                           {* {beat_to_seconds {elem $n 0}} 1000}
                        }
                     }
                     {++ [tracker2]}
                  }
               }
               {do
                  {set $n {elem [batch_notes] 0}}
                  {if [pass2]
                     {set_elem {eval {var {sprint [instrument] "_note_tracker_2"}}}
                        [tracker2]
                        {* {beat_to_seconds {elem $n 0}} 1000}
                     }
                  }
                  {++ [tracker2]}
               }
            }
            {set [batch_notes] {array ()}}
         }
      }
      {if {! [pass2]}
         {set_var {sprint [instrument] "_note_tracker"} {array [tracker]}}
         {set_var {sprint [instrument] "_note_tracker_2"} {array [tracker2]}}
         {set_var {sprint [instrument] "_note_tracker_2_size"} [tracker2]}
         {set_elem {eval {var {sprint [instrument] "_note_tracker"}}} 0 (none none)}
         {if [log_enabled]
            {notify {sprint [instrument] "count_note_tracker: " [tracker]}}
            {notify {sprint [instrument] "count_note_tracker2: " [tracker2]}}
            {notify {eval {var {sprint [instrument] "_note_tracker"}}}}
            {notify {sprint "count size:" {size {eval {var {sprint [instrument] "_note_tracker"}}}}}}
         }
      }
      {if [pass2]
         {if [log_enabled]
            {notify {sprint [instrument] "eval_note_tracker: " [tracker]}}
            {notify {eval {var {sprint [instrument] "_note_tracker"}}}}
            {notify {sprint "eval size:" {size {eval {var {sprint [instrument] "_note_tracker"}}}}}}
            {notify {sprint [instrument] "eval_note_tracker2: " [tracker2]}}
            {notify {eval {var {sprint [instrument] "_note_tracker_2"}}}}
            {notify {sprint os_blnk}}
            {notify {sprint "eval_2 size:" {size {eval {var {sprint [instrument] "_note_tracker_2"}}}}}}
         }
      }
   )
)

{new
   MidiParser
   timer_guitar
   (track_name 'PART GUITAR')
   (allowed_notes (96 97 98 99 100 103 120 116)) ;103 = solo, 120 = lowest of BRE, 116 - overdrive
   (init
      {$this set instrument guitar}
      {set $bre_start_time 0}
      {set_var {sprint [instrument] "_note_tracker"} {array 0}}
      {set_var {sprint [instrument] "_note_tracker_2"} {array 0}}
   )
   COMMON_STD_MIDIP
}
{new
   MidiParser
   eval_guitar
   (track_name 'PART GUITAR')
   (allowed_notes (96 97 98 99 100 103 120 116)) ;103 = solo, 120 = lowest of BRE ;116 - od
   (init {$this set instrument guitar} {$this set pass2 TRUE})
   COMMON_STD_MIDIP
}

{new
   MidiParser
   timer_bass
   (track_name 'PART BASS')
   (allowed_notes (96 97 98 99 100 103 116)) ;103 = solo, 120 = lowest of BRE ;116 - od
   (init
      {$this set instrument bass}
      {set_var {sprint [instrument] "_note_tracker"} {array 0}}
      {set_var {sprint [instrument] "_note_tracker_2"} {array 0}}
   )
   COMMON_STD_MIDIP
}
{new
   MidiParser
   eval_bass
   (track_name 'PART BASS')
   (allowed_notes (96 97 98 99 100 103 116)) ;116 - od ;103 - solo
   (init {$this set instrument bass} {$this set pass2 TRUE})
   COMMON_STD_MIDIP
}

{new
   MidiParser
   timer_vocals
   (track_name 'PART VOCALS')
   (allowed_notes (105 106 116)) ;116 - od ;103 - solo (not here)
   (init
      {$this set instrument vocals}
      {set_var {sprint [instrument] "_note_tracker"} {array 0}}
      {set_var {sprint [instrument] "_note_tracker_2"} {array 0}}
   )
   COMMON_STD_MIDIP
}
{new
   MidiParser
   eval_vocals
   (track_name 'PART VOCALS')
   (allowed_notes (105 106 116)) ;116 - od ;103 - solo (not here)
   (init {$this set instrument vocals} {$this set pass2 TRUE})
   COMMON_STD_MIDIP
}

{new
   MidiParser
   timer_real_guitar
   (track_name 'PART REAL_GUITAR')
   (allowed_notes (96 97 98 99 100 101 116 115)) ;120: BRE ;116 - od
   (init
      {$this set instrument real_guitar}
      {set_var {sprint [instrument] "_note_tracker"} {array 0}}
      {set_var {sprint [instrument] "_note_tracker_2"} {array 0}}
   )
   COMMON_STD_MIDIP
}
{new
   MidiParser
   eval_real_guitar
   (track_name 'PART REAL_GUITAR')
   (allowed_notes (96 97 98 99 100 101 116 115)) ;120: BRE ;116 - od
   (init {$this set instrument real_guitar} {$this set pass2 TRUE})
   COMMON_STD_MIDIP
}

{new
   MidiParser
   timer_real_bass
   (track_name 'PART REAL_BASS')
   (allowed_notes (96 97 98 99 100 101 116 115)) ;120: BRE ;116 - od
   (init
      {$this set instrument real_bass}
      {set_var {sprint [instrument] "_note_tracker"} {array 0}}
      {set_var {sprint [instrument] "_note_tracker_2"} {array 0}}
   )
   COMMON_STD_MIDIP
}
{new
   MidiParser
   eval_real_bass
   (track_name 'PART REAL_BASS')
   (allowed_notes (96 97 98 99 100 101 116 115)) ;120: BRE ;116 - od
   (init {$this set instrument real_bass} {$this set pass2 TRUE})
   COMMON_STD_MIDIP
}

{new
   MidiParser
   timer_harm
   (track_name 'HARM1')
   (allowed_notes (105 106 116)) ;116 - od ;103 - solo (not here)
   (init
      {$this set instrument harm}
      {set_var {sprint [instrument] "_note_tracker"} {array 0}}
      {set_var {sprint [instrument] "_note_tracker_2"} {array 0}}
   )
   COMMON_STD_MIDIP
}
{new
   MidiParser
   eval_harm
   (track_name 'HARM1')
   (allowed_notes (105 106 116)) ;116 - od ;103 - solo (not here)
   (init {$this set instrument harm} {$this set pass2 TRUE})
   COMMON_STD_MIDIP
}

{new
   MidiParser
   timer_drum
   (track_name 'PART DRUMS')
   (allowed_notes ;116 - od ;103 - solo
      #ifdef RB3E
      {if_else {dx_check_rb3e_modifier mod_double_bass}
         (95 96 97 98 99 100 103 116)
         (96 97 98 99 100 103 116)
      }
      #else
      (96 97 98 99 100 103 116)
      #endif
   )
   (init
      {$this set instrument drum}
      {set_var {sprint [instrument] "_note_tracker"} {array 0}}
      {set_var {sprint [instrument] "_note_tracker_2"} {array 0}}
      {set_var {sprint "real_drum" "_note_tracker"} {array 0}}
      {set_var {sprint "real_drum" "_note_tracker_2"} {array 0}}
   )
   COMMON_STD_MIDIP
}
{new
   MidiParser
   eval_drum
   (track_name 'PART DRUMS')
   (allowed_notes ;116 - od ;103 - solo
      #ifdef RB3E
      {if_else {dx_check_rb3e_modifier mod_double_bass}
         (95 96 97 98 99 100 103 103 116)
         (96 97 98 99 100 103 103 116)
      }
      #else
      (96 97 98 99 100 103 103 116)
      #endif
   )
   (init {$this set instrument drum} {$this set pass2 TRUE})
   COMMON_STD_MIDIP
}
{new
   MidiParser
   timer_real_drum
   (track_name 'PART DRUMS')
   (allowed_notes ;116 - od ;103 - solo
      #ifdef RB3E
      {if_else {dx_check_rb3e_modifier mod_double_bass}
         (95 96 97 98 99 100 103 116)
         (96 97 98 99 100 103 116)
      }
      #else
      (96 97 98 99 100 103 116)
      #endif
   )
   (init
      {$this set instrument real_drum}
      {set_var {sprint [instrument] "_note_tracker"} {array 0}}
      {set_var {sprint [instrument] "_note_tracker_2"} {array 0}}
      {set_var {sprint "real_drum" "_note_tracker"} {array 0}}
      {set_var {sprint "real_drum" "_note_tracker_2"} {array 0}}
   )
   COMMON_STD_MIDIP
}
{new
   MidiParser
   eval_real_drum
   (track_name 'PART DRUMS')
   (allowed_notes ;116 - od ;103 - solo
      #ifdef RB3E
      {if_else {dx_check_rb3e_modifier mod_double_bass}
         (95 96 97 98 99 100 103 103 116)
         (96 97 98 99 100 103 103 116)
      }
      #else
      (96 97 98 99 100 103 103 116)
      #endif
   )
   (init {$this set instrument real_drum} {$this set pass2 TRUE})
   COMMON_STD_MIDIP
}

{new
  MidiParser
  timer_keys
  (track_name 'PART KEYS')
  (allowed_notes (96 97 98 99 100 103 116)) ;116 od ;103 solo
  (init
    {$this set instrument keys}
    {$this set pass2 FALSE}
    {set_var {sprint [instrument] "_note_tracker"}   {array 0}}
    {set_var {sprint [instrument] "_note_tracker_2"} {array 0}}
  )
  COMMON_STD_MIDIP
}

{new
  MidiParser
  eval_keys
  (track_name 'PART KEYS')
  (allowed_notes (96 97 98 99 100 103 116)) ;116 od ;103 solo
  (init {$this set instrument keys} {$this set pass2 TRUE})
  COMMON_STD_MIDIP
}

{new
  MidiParser
  timer_real_keys
  (track_name 'PART REAL_KEYS_X')
  (allowed_notes (48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 115 116)) ;115: solo, 116: glissando, 120: BRE
  (init
    {$this set instrument real_keys}
    {$this set pass2 FALSE}
    {set_var {sprint [instrument] "_note_tracker"}   {array 0}}
    {set_var {sprint [instrument] "_note_tracker_2"} {array 0}}
  )
  COMMON_STD_MIDIP
}

{new
  MidiParser
  eval_real_keys
  (track_name 'PART REAL_KEYS_X')
  (allowed_notes (48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 115 116)) ;115: solo, 116: glissando, 120: BRE
  (init {$this set instrument real_keys} {$this set pass2 TRUE})
  COMMON_STD_MIDIP
}